<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Midpoint Line Drawer with Zoom & Rotate</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior: none; /* Prevents pull-to-refresh on mobile */
        }
        canvas {
            cursor: crosshair;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            touch-action: none; /* Disables browser handling of touch events like panning */
            transition: box-shadow 0.2s ease-in-out;
        }
        .dragover {
            box-shadow: 0 0 0 4px #4f46e5 !important; /* Indigo 600 */
        }
        .controls-card {
            background-color: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(200, 200, 200, 0.5);
        }
        .mode-active {
            background-color: #4f46e5 !important; /* Indigo 600 */
            color: white !important;
            box-shadow: 0 0 0 2px white, 0 0 0 4px #4f46e5;
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        #cameraModal {
            background-color: rgba(0, 0, 0, 0.5);
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-5xl mx-auto">
        <div class="text-center mb-6">
            <h1 class="text-3xl font-bold text-gray-900">Advanced Image Measurement Tool</h1>
            <p class="text-gray-600 mt-2">Zoom, pan, rotate, and draw horizontal midlines on your image.</p>
        </div>

        <div class="bg-white p-4 sm:p-6 rounded-xl shadow-lg">
            <div class="relative" id="canvas-container" oncontextmenu="return false;">
                <canvas id="imageCanvas"></canvas>
            </div>
        </div>

        <div class="controls-card w-full max-w-5xl mx-auto mt-6 p-4 rounded-lg shadow-md">
            <div class="grid grid-cols-2 md:grid-cols-5 gap-x-6 gap-y-4 items-center">
                <!-- Image Input Group -->
                <div class="col-span-2 md:col-span-1 flex flex-col gap-3">
                    <div>
                        <label for="imageLoader" class="sr-only">Upload Image</label>
                        <input type="file" id="imageLoader" accept="image/*" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-violet-50 file:text-violet-700 hover:file:bg-violet-100">
                    </div>
                    <button id="cameraButton" class="w-full bg-cyan-500 hover:bg-cyan-600 text-white font-bold py-2 px-3 rounded-full transition-all duration-200 shadow-md text-sm">Take Picture</button>
                </div>

                <!-- Image Control Group -->
                <div class="flex items-center justify-center gap-2">
                    <button id="rotateModeButton" class="w-full bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-2 px-3 rounded-full transition-all duration-200 shadow-md text-sm">Rotation</button>
                </div>

                <!-- Zoom Group -->
                <div class="flex items-center justify-center gap-2">
                    <button id="zoomOutButton" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold p-2 rounded-full w-10 h-10">-</button>
                    <span class="text-sm font-medium text-gray-700">Zoom</span>
                    <button id="zoomInButton" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold p-2 rounded-full w-10 h-10">+</button>
                </div>

                <!-- Action Buttons Group 1 -->
                <div class="flex items-center justify-center gap-2">
                    <button id="undoButton" class="w-full bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-3 rounded-full transition-all duration-200 shadow-md text-sm">Undo</button>
                    <button id="resetButton" class="w-full bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-3 rounded-full transition-all duration-200 shadow-md text-sm">Reset</button>
                </div>
                
                <!-- Action Buttons Group 2 -->
                <div class="flex items-center justify-center gap-2">
                     <button id="deleteButton" class="w-full bg-gray-700 hover:bg-gray-800 text-white font-bold py-2 px-3 rounded-full transition-all duration-200 shadow-md text-sm">Delete</button>
                    <button id="saveButton" class="w-full bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-3 rounded-full transition-all duration-200 shadow-md text-sm">Save</button>
                </div>
            </div>
            <p id="instructionText" class="text-center text-violet-700 font-medium mt-4">Click to select Point 1 of 4. Use scroll wheel to zoom. Drag & drop an image file onto the canvas to load it.</p>
            <div id="measurementResults" class="text-center text-gray-800 font-semibold mt-4 border-t pt-3 grid grid-cols-1 md:grid-cols-3 gap-2"></div>
        </div>
    </div>

    <!-- Camera Modal -->
    <div id="cameraModal" class="fixed inset-0 z-50 hidden items-center justify-center p-4">
        <div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-2xl">
            <h3 class="text-lg font-medium leading-6 text-gray-900 mb-4">Camera</h3>
            <video id="videoFeed" class="w-full rounded-md bg-gray-200" autoplay playsinline></video>
            <div class="mt-5 sm:mt-6 flex flex-col sm:flex-row gap-3">
                <button id="captureButton" type="button" class="inline-flex w-full justify-center rounded-md bg-indigo-600 px-4 py-2 text-base font-medium text-white shadow-sm hover:bg-indigo-700">Capture</button>
                <button id="closeModalButton" type="button" class="inline-flex w-full justify-center rounded-md bg-white px-4 py-2 text-base font-medium text-gray-700 shadow-sm ring-1 ring-inset ring-gray-300 hover:bg-gray-50">Close</button>
            </div>
        </div>
    </div>

    <script>
        // --- DOM Element Selection ---
        const canvas = document.getElementById('imageCanvas');
        const ctx = canvas.getContext('2d');
        const imageLoader = document.getElementById('imageLoader');
        const resetButton = document.getElementById('resetButton');
        const instructionText = document.getElementById('instructionText');
        const canvasContainer = document.getElementById('canvas-container');
        const rotateModeButton = document.getElementById('rotateModeButton');
        const zoomInButton = document.getElementById('zoomInButton');
        const zoomOutButton = document.getElementById('zoomOutButton');
        const saveButton = document.getElementById('saveButton');
        const undoButton = document.getElementById('undoButton');
        const deleteButton = document.getElementById('deleteButton'); // New button
        const measurementResults = document.getElementById('measurementResults');
        const cameraButton = document.getElementById('cameraButton');
        const cameraModal = document.getElementById('cameraModal');
        const videoFeed = document.getElementById('videoFeed');
        const captureButton = document.getElementById('captureButton');
        const closeModalButton = document.getElementById('closeModalButton');

        // --- State Management ---
        const image = new Image();
        image.crossOrigin = "Anonymous"; // Required for saving canvas with external image
        let imageLoaded = false;
        let points = [];
        let rotationPoints = [];
        let mode = 'points'; // 'points' or 'rotate'
        let undoHistory = [];
        let cameraStream = null;
        
        // Transformation state
        let transform = {
            scale: 1,
            offsetX: 0,
            offsetY: 0,
            rotation: 0
        };

        // Panning state
        let isPanning = false;
        let panStart = { x: 0, y: 0 };
        
        // --- Default Image ---
        const placeholderSrc = `https://placehold.co/800x600/e2e8f0/4a5568?text=Upload+or+Capture+Image`;
        image.src = 'microscope2.jpg';
        image.onerror = () => {
            console.log("Default image failed. Using placeholder.");
            image.src = placeholderSrc;
        };

        // --- Event Listeners ---
        imageLoader.addEventListener('change', handleImageUpload);
        resetButton.addEventListener('click', resetAll);
        rotateModeButton.addEventListener('click', toggleRotateMode);
        zoomInButton.addEventListener('click', () => zoom(1.2));
        zoomOutButton.addEventListener('click', () => zoom(1 / 1.2));
        saveButton.addEventListener('click', saveCanvasAsImage);
        undoButton.addEventListener('click', handleUndo);
        deleteButton.addEventListener('click', deleteImage); // New listener
        cameraButton.addEventListener('click', startCamera);
        closeModalButton.addEventListener('click', stopCamera);
        captureButton.addEventListener('click', captureImage);

        canvas.addEventListener('wheel', handleWheel, { passive: false });
        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('mouseup', handleMouseUp);
        canvas.addEventListener('mouseleave', handleMouseUp);
        
        canvas.addEventListener('touchstart', handleTouchStart);
        canvas.addEventListener('touchmove', handleTouchMove);
        canvas.addEventListener('touchend', handleTouchEnd);
        canvas.addEventListener('touchcancel', handleTouchEnd);

        // Drag and Drop Listeners
        canvasContainer.addEventListener('dragover', handleDragOver);
        canvasContainer.addEventListener('dragleave', handleDragLeave);
        canvasContainer.addEventListener('drop', handleDrop);

        window.addEventListener('resize', handleResize);
        image.onload = () => {
            imageLoaded = true;
            resetAll();
        };

        // --- Core Functions ---

        function handleResize() {
            if (!imageLoaded) return;
            const containerWidth = canvasContainer.clientWidth;
            const scaleRatio = containerWidth / image.naturalWidth;
            canvas.width = containerWidth;
            canvas.height = image.naturalHeight * scaleRatio;
            resetAll();
        }

        function redrawCanvas(targetCtx = ctx, useScreenTransform = true) {
            if (!imageLoaded) return;
            
            targetCtx.save();
            targetCtx.setTransform(1, 0, 0, 1, 0, 0);
            targetCtx.clearRect(0, 0, targetCtx.canvas.width, targetCtx.canvas.height);
            
            if (useScreenTransform) {
                targetCtx.translate(transform.offsetX, transform.offsetY);
                targetCtx.scale(transform.scale, transform.scale);
            }
            
            const imgCenterX = image.naturalWidth / 2;
            const imgCenterY = image.naturalHeight / 2;
            targetCtx.translate(imgCenterX, imgCenterY);
            targetCtx.rotate(transform.rotation);
            targetCtx.translate(-imgCenterX, -imgCenterY);
            
            targetCtx.drawImage(image, 0, 0, image.naturalWidth, image.naturalHeight);

            const allPoints = (mode === 'rotate' ? rotationPoints : points);
            const currentScale = useScreenTransform ? transform.scale : 1;
            allPoints.forEach((p, i) => drawPoint(p, i + 1, targetCtx, currentScale));
            
            if (points.length >= 2) {
                drawHalfVerticalDistanceIndicator(targetCtx, currentScale);
            }
            if (points.length >= 4) {
                drawHorizontalMidline(points[0], points[1], 'rgba(255, 107, 107, 0.9)', 2, targetCtx, currentScale);
                drawHorizontalMidline(points[2], points[3], 'rgba(59, 130, 246, 0.9)', 2, targetCtx, currentScale);
                drawMidlineDistanceIndicator(targetCtx, currentScale);
            }
            
            targetCtx.restore();
            updateMeasurementDisplay();
        }

        // --- Event Handlers ---

        function processImageFile(file) {
            if (file && file.type.startsWith('image/')) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    image.src = event.target.result;
                };
                reader.readAsDataURL(file);
            }
        }

        function handleImageUpload(e) {
            processImageFile(e.target.files[0]);
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.stopPropagation();
            canvas.classList.add('dragover');
        }

        function handleDragLeave(e) {
            e.preventDefault();
            e.stopPropagation();
            canvas.classList.remove('dragover');
        }

        function handleDrop(e) {
            e.preventDefault();
            e.stopPropagation();
            canvas.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            processImageFile(file);
        }

        function handleMouseDown(e) {
            if (e.button === 0) { // Left click
                handleCanvasClick(e);
            } else if (e.button === 2) { // Right click
                isPanning = true;
                panStart.x = e.clientX;
                panStart.y = e.clientY;
                canvas.style.cursor = 'grabbing';
            }
        }

        function handleMouseMove(e) {
            if (!isPanning) return;
            const dx = e.clientX - panStart.x;
            const dy = e.clientY - panStart.y;
            transform.offsetX += dx;
            transform.offsetY += dy;
            panStart.x = e.clientX;
            panStart.y = e.clientY;
            redrawCanvas();
        }

        function handleMouseUp(e) {
            isPanning = false;
            canvas.style.cursor = 'crosshair';
        }

        function handleWheel(e) {
            e.preventDefault();
            const zoomIntensity = 0.1;
            const scaleFactor = e.deltaY < 0 ? 1 + zoomIntensity : 1 - zoomIntensity;
            zoom(scaleFactor, e.clientX, e.clientY);
        }
        
        let initialPinchDistance = null;
        let lastTouch = null;

        function handleTouchStart(e) {
            if (e.touches.length === 1) {
                isPanning = true;
                panStart.x = e.touches[0].clientX;
                panStart.y = e.touches[0].clientY;
                lastTouch = { x: panStart.x, y: panStart.y, time: Date.now() };
            } else if (e.touches.length === 2) {
                isPanning = false;
                initialPinchDistance = getPinchDistance(e.touches);
            }
        }

        function handleTouchMove(e) {
            e.preventDefault();
            if (isPanning && e.touches.length === 1) {
                const dx = e.touches[0].clientX - panStart.x;
                const dy = e.touches[0].clientY - panStart.y;
                transform.offsetX += dx;
                transform.offsetY += dy;
                panStart.x = e.touches[0].clientX;
                panStart.y = e.touches[0].clientY;
                redrawCanvas();
            } else if (e.touches.length === 2 && initialPinchDistance) {
                const newDist = getPinchDistance(e.touches);
                const scaleFactor = newDist / initialPinchDistance;
                const midX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                const midY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
                zoom(scaleFactor, midX, midY);
                initialPinchDistance = newDist;
            }
        }
        
        function handleTouchEnd(e) {
            if (e.touches.length < 2) initialPinchDistance = null;
            if (e.touches.length < 1) {
                isPanning = false;
                if (lastTouch) {
                    const dx = e.changedTouches[0].clientX - lastTouch.x;
                    const dy = e.changedTouches[0].clientY - lastTouch.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    const time = Date.now() - lastTouch.time;
                    if (dist < 10 && time < 200) {
                        handleCanvasClick(e.changedTouches[0]);
                    }
                }
            }
        }

        function getPinchDistance(touches) {
            const dx = touches[0].clientX - touches[1].clientX;
            const dy = touches[0].clientY - touches[1].clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function handleCanvasClick(e) {
            const point = getCanvasCoordinates(e);

            if (mode === 'points') {
                if (points.length < 4) {
                    saveState();
                    points.push(point);
                }
            } else if (mode === 'rotate') {
                if (rotationPoints.length < 2) {
                    saveState();
                    rotationPoints.push(point);
                    if (rotationPoints.length === 2) {
                        setRotation();
                        toggleRotateMode();
                    }
                }
            }
            updateInstructionText();
            redrawCanvas();
        }

        // --- Transformation and Drawing ---

        function zoom(scaleFactor, clientX, clientY) {
            const rect = canvas.getBoundingClientRect();
            const mx = clientX !== undefined ? clientX - rect.left : canvas.width / 2;
            const my = clientY !== undefined ? clientY - rect.top : canvas.height / 2;
            transform.offsetX = mx - (mx - transform.offsetX) * scaleFactor;
            transform.offsetY = my - (my - transform.offsetY) * scaleFactor;
            transform.scale *= scaleFactor;
            redrawCanvas();
        }

        function drawPoint(point, label, targetCtx, scale) {
            targetCtx.beginPath();
            targetCtx.arc(point.x, point.y, 5 / scale, 0, 2 * Math.PI);
            targetCtx.fillStyle = '#c026d3';
            targetCtx.fill();
            targetCtx.font = `${14 / scale}px Inter`;
            targetCtx.fillText(label, point.x + 8 / scale, point.y + 5 / scale);
        }
        
        function drawHorizontalMidline(p1, p2, color, lineWidth, targetCtx, scale) {
            const midX = (p1.x + p2.x) / 2;
            const midY = (p1.y + p2.y) / 2;
            const angle = -transform.rotation;
            const veryLong = Math.max(image.naturalWidth, image.naturalHeight) * 2;
            const startX = midX - veryLong * Math.cos(angle);
            const startY = midY - veryLong * Math.sin(angle);
            const endX = midX + veryLong * Math.cos(angle);
            const endY = midY + veryLong * Math.sin(angle);

            targetCtx.beginPath();
            targetCtx.strokeStyle = color;
            targetCtx.lineWidth = lineWidth / scale;
            targetCtx.setLineDash([8 / scale, 8 / scale]);
            targetCtx.moveTo(startX, startY);
            targetCtx.lineTo(endX, endY);
            targetCtx.stroke();
            targetCtx.setLineDash([]);
        }

        function drawMidlineDistanceIndicator(targetCtx, scale) {
            const screenPoints = points.map(p => transformPointToScreen(p));
            const screenMidY1 = (screenPoints[0].y + screenPoints[1].y) / 2;
            const screenMidY2 = (screenPoints[2].y + screenPoints[3].y) / 2;
            const avgScreenX = (screenPoints[0].x + screenPoints[1].x + screenPoints[2].x + screenPoints[3].x) / 4;
            const screenStart = { x: avgScreenX, y: screenMidY1 };
            const screenEnd = { x: avgScreenX, y: screenMidY2 };
            const imageStart = transformScreenToPoint(screenStart);
            const imageEnd = transformScreenToPoint(screenEnd);

            targetCtx.beginPath();
            targetCtx.strokeStyle = 'rgba(0, 255, 255, 0.9)'; // Cyan
            targetCtx.lineWidth = 2 / scale;
            targetCtx.moveTo(imageStart.x, imageStart.y);
            targetCtx.lineTo(imageEnd.x, imageEnd.y);
            const capLength = 8 / scale;
            const angle = -transform.rotation;
            const capDx = capLength * Math.cos(angle);
            const capDy = capLength * Math.sin(angle);
            targetCtx.moveTo(imageStart.x - capDx, imageStart.y - capDy);
            targetCtx.lineTo(imageStart.x + capDx, imageStart.y + capDy);
            targetCtx.moveTo(imageEnd.x - capDx, imageEnd.y - capDy);
            targetCtx.lineTo(imageEnd.x + capDx, imageEnd.y + capDy);
            targetCtx.stroke();
        }

        function drawHalfVerticalDistanceIndicator(targetCtx, scale) {
            const screenP1 = transformPointToScreen(points[0]);
            const screenP2 = transformPointToScreen(points[1]);
            
            const avgScreenX = (screenP1.x + screenP2.x) / 2 + 20;
            const screenMidY = (screenP1.y + screenP2.y) / 2;

            const screenStart = { x: avgScreenX, y: screenP1.y };
            const screenEnd = { x: avgScreenX, y: screenMidY };
            
            const imageStart = transformScreenToPoint(screenStart);
            const imageEnd = transformScreenToPoint(screenEnd);

            targetCtx.beginPath();
            targetCtx.strokeStyle = 'rgba(219, 39, 119, 0.9)'; // Magenta
            targetCtx.lineWidth = 2 / scale;
            targetCtx.moveTo(imageStart.x, imageStart.y);
            targetCtx.lineTo(imageEnd.x, imageEnd.y);
            const capLength = 8 / scale;
            const angle = -transform.rotation;
            const capDx = capLength * Math.cos(angle);
            const capDy = capLength * Math.sin(angle);
            targetCtx.moveTo(imageStart.x - capDx, imageStart.y - capDy);
            targetCtx.lineTo(imageStart.x + capDx, imageStart.y + capDy);
            targetCtx.moveTo(imageEnd.x - capDx, imageEnd.y - capDy);
            targetCtx.lineTo(imageEnd.x + capDx, imageEnd.y + capDy);
            targetCtx.stroke();
        }

        // --- Camera Functionality ---
        async function startCamera() {
            cameraModal.style.display = 'flex';
            try {
                cameraStream = await navigator.mediaDevices.getUserMedia({ video: true });
                videoFeed.srcObject = cameraStream;
            } catch (err) {
                console.error("Error accessing camera: ", err);
                instructionText.textContent = "Could not access camera. Please check permissions.";
                stopCamera();
            }
        }

        function stopCamera() {
            if (cameraStream) {
                cameraStream.getTracks().forEach(track => track.stop());
            }
            cameraModal.style.display = 'none';
        }

        function captureImage() {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = videoFeed.videoWidth;
            tempCanvas.height = videoFeed.videoHeight;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(videoFeed, 0, 0, tempCanvas.width, tempCanvas.height);
            image.src = tempCanvas.toDataURL('image/png');
            stopCamera();
        }

        // --- Save Functionality ---
        function saveCanvasAsImage() {
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = image.naturalWidth;
            tempCanvas.height = image.naturalHeight;
            redrawCanvas(tempCtx, false);
            const link = document.createElement('a');
            link.download = 'measurement-output.png';
            link.href = tempCanvas.toDataURL('image/png');
            link.click();
        }

        // --- Undo Functionality ---
        function saveState() {
            const state = {
                points: JSON.parse(JSON.stringify(points)),
                rotationPoints: JSON.parse(JSON.stringify(rotationPoints)),
                transform: JSON.parse(JSON.stringify(transform)),
                mode: mode
            };
            undoHistory.push(state);
            updateUndoButtonState();
        }

        function handleUndo() {
            if (undoHistory.length === 0) return;
            const lastState = undoHistory.pop();
            points = lastState.points;
            rotationPoints = lastState.rotationPoints;
            transform = lastState.transform;
            mode = lastState.mode;

            if (mode === 'rotate') {
                 rotateModeButton.classList.add('mode-active');
            } else {
                 rotateModeButton.classList.remove('mode-active');
            }

            updateUndoButtonState();
            updateInstructionText();
            redrawCanvas();
        }

        function updateUndoButtonState() {
            undoButton.disabled = undoHistory.length === 0;
        }

        // --- Mode and State Management ---

        function toggleRotateMode() {
            saveState();
            if (mode === 'rotate') {
                mode = 'points';
                rotateModeButton.classList.remove('mode-active');
                rotationPoints = [];
            } else {
                mode = 'rotate';
                rotateModeButton.classList.add('mode-active');
                points = [];
            }
            updateInstructionText();
            redrawCanvas();
        }
        
        function setRotation() {
            if (rotationPoints.length < 2) return;
            saveState();
            const p1 = rotationPoints[0];
            const p2 = rotationPoints[1];
            const dy = p2.y - p1.y;
            const dx = p2.x - p1.x;
            transform.rotation = -Math.atan2(dy, dx);
            redrawCanvas();
        }

        function resetAll() {
            points = [];
            rotationPoints = [];
            transform = { scale: 1, offsetX: 0, offsetY: 0, rotation: 0 };
            undoHistory = [];
            if (mode === 'rotate') {
                mode = 'points';
                rotateModeButton.classList.remove('mode-active');
            }
            handleResizeInitial();
            updateInstructionText();
            updateUndoButtonState();
        }

        function deleteImage() {
            image.src = placeholderSrc; // This will trigger onload, which calls resetAll
        }

        function handleResizeInitial() {
            if (!imageLoaded) return;
            const containerWidth = canvasContainer.clientWidth;
            const scaleRatio = containerWidth / image.naturalWidth;
            canvas.width = containerWidth;
            canvas.height = image.naturalHeight * scaleRatio;
            transform.scale = canvas.width / image.naturalWidth;
            transform.offsetX = 0;
            transform.offsetY = (canvas.height - image.naturalHeight * transform.scale) / 2;
            redrawCanvas();
        }
        
        function updateMeasurementDisplay() {
            if (points.length < 4) {
                measurementResults.innerHTML = '';
                return;
            }
            
            const screenPoints = points.map(p => transformPointToScreen(p));

            const screenMidY1 = (screenPoints[0].y + screenPoints[1].y) / 2;
            const screenMidY2 = (screenPoints[2].y + screenPoints[3].y) / 2;
            const hLinesDist = Math.abs(screenMidY1 - screenMidY2);

            const firstPointsVerticalDist = Math.abs(screenPoints[0].y - screenPoints[1].y);
            const halfFirstPointsDist = firstPointsVerticalDist / 2;

            const ratio = hLinesDist / halfFirstPointsDist;
            let angleDeg = NaN;
            if (ratio >= -1 && ratio <= 1 && halfFirstPointsDist > 1e-6) {
                const angleRad = Math.asin(ratio);
                angleDeg = angleRad * (180 / Math.PI);
            }

            measurementResults.innerHTML = `
                <div>Vertical Distance Between Midlines: <strong class="text-blue-600">${hLinesDist.toFixed(2)}px</strong></div>
                <div>Half Vertical Distance (Pts 1-2): <strong class="text-red-600">${halfFirstPointsDist.toFixed(2)}px</strong></div>
                <div>Calculated Angle: <strong class="text-green-600">${isNaN(angleDeg) ? 'Invalid' : angleDeg.toFixed(2) + '°'}</strong></div>
            `;
        }

        function updateInstructionText() {
            if (mode === 'rotate') {
                const pointsNeeded = 2 - rotationPoints.length;
                instructionText.textContent = `Rotation Mode: Click to define a horizontal line. Point ${rotationPoints.length + 1} of 2.`;
            } else {
                const pointsNeeded = 4 - points.length;
                if (pointsNeeded > 0) {
                     instructionText.textContent = `Click to select Point ${points.length + 1} of 4.`;
                } else {
                    instructionText.textContent = 'All points selected! Reset to start over.';
                }
            }
        }
        
        // --- Utility Functions ---

        function getCanvasCoordinates(e) { // Screen to Image
            const rect = canvas.getBoundingClientRect();
            const clientX = e.clientX - rect.left;
            const clientY = e.clientY - rect.top;
            return transformScreenToPoint({ x: clientX, y: clientY });
        }

        function transformScreenToPoint(screenPoint) { // Screen to Image
             const domMatrix = new DOMMatrix()
                .translateSelf(transform.offsetX, transform.offsetY)
                .scaleSelf(transform.scale, transform.scale)
                .translateSelf(image.naturalWidth / 2, image.naturalHeight / 2)
                .rotateSelf(transform.rotation * 180 / Math.PI)
                .translateSelf(-image.naturalWidth / 2, -image.naturalHeight / 2)
                .invertSelf();
            return new DOMPoint(screenPoint.x, screenPoint.y).matrixTransform(domMatrix);
        }

        function transformPointToScreen(imagePoint) { // Image to Screen
            const domMatrix = new DOMMatrix()
                .translateSelf(transform.offsetX, transform.offsetY)
                .scaleSelf(transform.scale, transform.scale)
                .translateSelf(image.naturalWidth / 2, image.naturalHeight / 2)
                .rotateSelf(transform.rotation * 180 / Math.PI)
                .translateSelf(-image.naturalWidth / 2, -image.naturalHeight / 2);
            return new DOMPoint(imagePoint.x, imagePoint.y).matrixTransform(domMatrix);
        }

        // Initial UI state setup
        updateUndoButtonState();
    </script>
</body>
</html>
